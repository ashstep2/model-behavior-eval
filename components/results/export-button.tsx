'use client';

import { useState } from 'react';
import { Button } from '@/components/ui/button';
import { EvaluationResults } from '@/types';
import { getModelDisplayName } from '@/lib/data/models';
import { getDimensionDisplayName } from '@/lib/data/dimensions';

interface ExportButtonProps {
  results: EvaluationResults;
}

export function ExportButton({ results }: ExportButtonProps) {
  const [isExporting, setIsExporting] = useState(false);

  const handleExport = async () => {
    setIsExporting(true);

    try {
      const markdown = generateMarkdown(results);

      const blob = new Blob([markdown], { type: 'text/markdown' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `evaluation-${results.id.slice(0, 8)}.md`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    } catch (error) {
      console.error('Export failed:', error);
    } finally {
      setIsExporting(false);
    }
  };

  return (
    <Button variant="secondary" onClick={handleExport} loading={isExporting}>
      Export
    </Button>
  );
}

function generateMarkdown(results: EvaluationResults): string {
  const { summary, byModel, byTest, recommendation } = results;

  const lines: string[] = [];

  lines.push(`# Model Behavior Evaluation`);
  lines.push('');
  lines.push(`**Use Case:** ${results.useCaseName}`);
  lines.push(`**Date:** ${new Date(results.completedAt).toLocaleDateString()}`);
  lines.push(`**Models:** ${results.models.map(getModelDisplayName).join(', ')}`);
  lines.push('');

  lines.push('## Summary');
  lines.push('');
  lines.push(`**Winner:** ${getModelDisplayName(summary.winner)} (${summary.winnerScore.toFixed(1)}/5)`);
  lines.push('');

  lines.push('| Model | Score |');
  lines.push('|-------|-------|');
  Object.entries(summary.scores)
    .sort(([, a], [, b]) => b - a)
    .forEach(([modelId, score]) => {
      lines.push(`| ${getModelDisplayName(modelId)} | ${score.toFixed(1)}/5 |`);
    });
  lines.push('');

  lines.push('## Recommendation');
  lines.push('');
  lines.push(recommendation);
  lines.push('');

  lines.push('## Dimension Breakdown');
  lines.push('');

  const modelIds = Object.keys(byModel);
  const header = ['Dimension', ...modelIds.map(getModelDisplayName)].join(' | ');
  const separator = ['---', ...modelIds.map(() => '---')].join(' | ');

  lines.push(`| ${header} |`);
  lines.push(`| ${separator} |`);

  const dimensions = Object.keys(byModel[modelIds[0]].dimensionScores);
  dimensions.forEach((dim) => {
    const scores = modelIds.map(
      (id) => byModel[id].dimensionScores[dim as keyof typeof byModel[typeof id]['dimensionScores']]
    );
    const row = [
      getDimensionDisplayName(dim as any),
      ...scores.map((s) => s.toFixed(1)),
    ].join(' | ');
    lines.push(`| ${row} |`);
  });
  lines.push('');

  lines.push('## Test Details');
  lines.push('');

  byTest.forEach((test, index) => {
    lines.push(`### ${index + 1}. ${test.testCase.name}`);
    lines.push('');
    lines.push('**Prompt:**');
    lines.push('```');
    lines.push(test.testCase.prompt);
    lines.push('```');
    lines.push('');

    lines.push('**Scores:**');
    test.scores.forEach((score) => {
      lines.push(`- ${getModelDisplayName(score.modelId)}: ${score.overallScore.toFixed(1)}/5`);
    });
    lines.push('');

    if (test.comparison) {
      lines.push(`**Analysis:** ${test.comparison}`);
      lines.push('');
    }
  });

  lines.push('---');
  lines.push('*Generated by Model Behavior Eval*');

  return lines.join('\n');
}
